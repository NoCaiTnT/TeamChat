// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: weather.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_weather_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_weather_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_weather_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_weather_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_weather_2eproto;
namespace weather {
class ForecastWeather;
struct ForecastWeatherDefaultTypeInternal;
extern ForecastWeatherDefaultTypeInternal _ForecastWeather_default_instance_;
class ForecastWeatherReplay;
struct ForecastWeatherReplayDefaultTypeInternal;
extern ForecastWeatherReplayDefaultTypeInternal _ForecastWeatherReplay_default_instance_;
class LivesWeather;
struct LivesWeatherDefaultTypeInternal;
extern LivesWeatherDefaultTypeInternal _LivesWeather_default_instance_;
class LivesWeatherReplay;
struct LivesWeatherReplayDefaultTypeInternal;
extern LivesWeatherReplayDefaultTypeInternal _LivesWeatherReplay_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace weather
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace weather {

// ===================================================================


// -------------------------------------------------------------------

class UserInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:weather.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserInfo(::google::protobuf::internal::ConstantInitialized);

  inline UserInfo(const UserInfo& from)
      : UserInfo(nullptr, from) {}
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserInfo& from) {
    UserInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "weather.UserInfo";
  }
  protected:
  explicit UserInfo(::google::protobuf::Arena* arena);
  UserInfo(::google::protobuf::Arena* arena, const UserInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kUseripFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string userip = 2;
  void clear_userip() ;
  const std::string& userip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userip(Arg_&& arg, Args_... args);
  std::string* mutable_userip();
  PROTOBUF_NODISCARD std::string* release_userip();
  void set_allocated_userip(std::string* value);

  private:
  const std::string& _internal_userip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userip(
      const std::string& value);
  std::string* _internal_mutable_userip();

  public:
  // @@protoc_insertion_point(class_scope:weather.UserInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr userip_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weather_2eproto;
};// -------------------------------------------------------------------

class LivesWeather final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:weather.LivesWeather) */ {
 public:
  inline LivesWeather() : LivesWeather(nullptr) {}
  ~LivesWeather() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LivesWeather(::google::protobuf::internal::ConstantInitialized);

  inline LivesWeather(const LivesWeather& from)
      : LivesWeather(nullptr, from) {}
  LivesWeather(LivesWeather&& from) noexcept
    : LivesWeather() {
    *this = ::std::move(from);
  }

  inline LivesWeather& operator=(const LivesWeather& from) {
    CopyFrom(from);
    return *this;
  }
  inline LivesWeather& operator=(LivesWeather&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LivesWeather& default_instance() {
    return *internal_default_instance();
  }
  static inline const LivesWeather* internal_default_instance() {
    return reinterpret_cast<const LivesWeather*>(
               &_LivesWeather_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LivesWeather& a, LivesWeather& b) {
    a.Swap(&b);
  }
  inline void Swap(LivesWeather* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LivesWeather* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LivesWeather* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LivesWeather>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LivesWeather& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LivesWeather& from) {
    LivesWeather::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LivesWeather* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "weather.LivesWeather";
  }
  protected:
  explicit LivesWeather(::google::protobuf::Arena* arena);
  LivesWeather(::google::protobuf::Arena* arena, const LivesWeather& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeatherFieldNumber = 1,
    kTemperatureFieldNumber = 2,
    kWinddirectionFieldNumber = 3,
    kWindpowerFieldNumber = 4,
    kHumidityFieldNumber = 5,
    kReporttimeFieldNumber = 6,
    kTemperatureFloatFieldNumber = 7,
    kHumidityFloatFieldNumber = 8,
  };
  // string weather = 1;
  void clear_weather() ;
  const std::string& weather() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_weather(Arg_&& arg, Args_... args);
  std::string* mutable_weather();
  PROTOBUF_NODISCARD std::string* release_weather();
  void set_allocated_weather(std::string* value);

  private:
  const std::string& _internal_weather() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weather(
      const std::string& value);
  std::string* _internal_mutable_weather();

  public:
  // string temperature = 2;
  void clear_temperature() ;
  const std::string& temperature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_temperature(Arg_&& arg, Args_... args);
  std::string* mutable_temperature();
  PROTOBUF_NODISCARD std::string* release_temperature();
  void set_allocated_temperature(std::string* value);

  private:
  const std::string& _internal_temperature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_temperature(
      const std::string& value);
  std::string* _internal_mutable_temperature();

  public:
  // string winddirection = 3;
  void clear_winddirection() ;
  const std::string& winddirection() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_winddirection(Arg_&& arg, Args_... args);
  std::string* mutable_winddirection();
  PROTOBUF_NODISCARD std::string* release_winddirection();
  void set_allocated_winddirection(std::string* value);

  private:
  const std::string& _internal_winddirection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_winddirection(
      const std::string& value);
  std::string* _internal_mutable_winddirection();

  public:
  // string windpower = 4;
  void clear_windpower() ;
  const std::string& windpower() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_windpower(Arg_&& arg, Args_... args);
  std::string* mutable_windpower();
  PROTOBUF_NODISCARD std::string* release_windpower();
  void set_allocated_windpower(std::string* value);

  private:
  const std::string& _internal_windpower() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_windpower(
      const std::string& value);
  std::string* _internal_mutable_windpower();

  public:
  // string humidity = 5;
  void clear_humidity() ;
  const std::string& humidity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_humidity(Arg_&& arg, Args_... args);
  std::string* mutable_humidity();
  PROTOBUF_NODISCARD std::string* release_humidity();
  void set_allocated_humidity(std::string* value);

  private:
  const std::string& _internal_humidity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_humidity(
      const std::string& value);
  std::string* _internal_mutable_humidity();

  public:
  // string reporttime = 6;
  void clear_reporttime() ;
  const std::string& reporttime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reporttime(Arg_&& arg, Args_... args);
  std::string* mutable_reporttime();
  PROTOBUF_NODISCARD std::string* release_reporttime();
  void set_allocated_reporttime(std::string* value);

  private:
  const std::string& _internal_reporttime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reporttime(
      const std::string& value);
  std::string* _internal_mutable_reporttime();

  public:
  // string temperatureFloat = 7;
  void clear_temperaturefloat() ;
  const std::string& temperaturefloat() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_temperaturefloat(Arg_&& arg, Args_... args);
  std::string* mutable_temperaturefloat();
  PROTOBUF_NODISCARD std::string* release_temperaturefloat();
  void set_allocated_temperaturefloat(std::string* value);

  private:
  const std::string& _internal_temperaturefloat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_temperaturefloat(
      const std::string& value);
  std::string* _internal_mutable_temperaturefloat();

  public:
  // string humidityFloat = 8;
  void clear_humidityfloat() ;
  const std::string& humidityfloat() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_humidityfloat(Arg_&& arg, Args_... args);
  std::string* mutable_humidityfloat();
  PROTOBUF_NODISCARD std::string* release_humidityfloat();
  void set_allocated_humidityfloat(std::string* value);

  private:
  const std::string& _internal_humidityfloat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_humidityfloat(
      const std::string& value);
  std::string* _internal_mutable_humidityfloat();

  public:
  // @@protoc_insertion_point(class_scope:weather.LivesWeather)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      124, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr weather_;
    ::google::protobuf::internal::ArenaStringPtr temperature_;
    ::google::protobuf::internal::ArenaStringPtr winddirection_;
    ::google::protobuf::internal::ArenaStringPtr windpower_;
    ::google::protobuf::internal::ArenaStringPtr humidity_;
    ::google::protobuf::internal::ArenaStringPtr reporttime_;
    ::google::protobuf::internal::ArenaStringPtr temperaturefloat_;
    ::google::protobuf::internal::ArenaStringPtr humidityfloat_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weather_2eproto;
};// -------------------------------------------------------------------

class ForecastWeather final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:weather.ForecastWeather) */ {
 public:
  inline ForecastWeather() : ForecastWeather(nullptr) {}
  ~ForecastWeather() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ForecastWeather(::google::protobuf::internal::ConstantInitialized);

  inline ForecastWeather(const ForecastWeather& from)
      : ForecastWeather(nullptr, from) {}
  ForecastWeather(ForecastWeather&& from) noexcept
    : ForecastWeather() {
    *this = ::std::move(from);
  }

  inline ForecastWeather& operator=(const ForecastWeather& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForecastWeather& operator=(ForecastWeather&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForecastWeather& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForecastWeather* internal_default_instance() {
    return reinterpret_cast<const ForecastWeather*>(
               &_ForecastWeather_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ForecastWeather& a, ForecastWeather& b) {
    a.Swap(&b);
  }
  inline void Swap(ForecastWeather* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForecastWeather* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForecastWeather* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForecastWeather>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ForecastWeather& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ForecastWeather& from) {
    ForecastWeather::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ForecastWeather* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "weather.ForecastWeather";
  }
  protected:
  explicit ForecastWeather(::google::protobuf::Arena* arena);
  ForecastWeather(::google::protobuf::Arena* arena, const ForecastWeather& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDateFieldNumber = 1,
    kWeekFieldNumber = 2,
    kDayweatherFieldNumber = 3,
    kNightweatherFieldNumber = 4,
    kDaytempFieldNumber = 5,
    kNighttempFieldNumber = 6,
    kDaywindFieldNumber = 7,
    kNightwindFieldNumber = 8,
    kDaypowerFieldNumber = 9,
    kNightpowerFieldNumber = 10,
  };
  // string date = 1;
  void clear_date() ;
  const std::string& date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_date(Arg_&& arg, Args_... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* value);

  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(
      const std::string& value);
  std::string* _internal_mutable_date();

  public:
  // string week = 2;
  void clear_week() ;
  const std::string& week() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_week(Arg_&& arg, Args_... args);
  std::string* mutable_week();
  PROTOBUF_NODISCARD std::string* release_week();
  void set_allocated_week(std::string* value);

  private:
  const std::string& _internal_week() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_week(
      const std::string& value);
  std::string* _internal_mutable_week();

  public:
  // string dayweather = 3;
  void clear_dayweather() ;
  const std::string& dayweather() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dayweather(Arg_&& arg, Args_... args);
  std::string* mutable_dayweather();
  PROTOBUF_NODISCARD std::string* release_dayweather();
  void set_allocated_dayweather(std::string* value);

  private:
  const std::string& _internal_dayweather() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dayweather(
      const std::string& value);
  std::string* _internal_mutable_dayweather();

  public:
  // string nightweather = 4;
  void clear_nightweather() ;
  const std::string& nightweather() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nightweather(Arg_&& arg, Args_... args);
  std::string* mutable_nightweather();
  PROTOBUF_NODISCARD std::string* release_nightweather();
  void set_allocated_nightweather(std::string* value);

  private:
  const std::string& _internal_nightweather() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nightweather(
      const std::string& value);
  std::string* _internal_mutable_nightweather();

  public:
  // string daytemp = 5;
  void clear_daytemp() ;
  const std::string& daytemp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_daytemp(Arg_&& arg, Args_... args);
  std::string* mutable_daytemp();
  PROTOBUF_NODISCARD std::string* release_daytemp();
  void set_allocated_daytemp(std::string* value);

  private:
  const std::string& _internal_daytemp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_daytemp(
      const std::string& value);
  std::string* _internal_mutable_daytemp();

  public:
  // string nighttemp = 6;
  void clear_nighttemp() ;
  const std::string& nighttemp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nighttemp(Arg_&& arg, Args_... args);
  std::string* mutable_nighttemp();
  PROTOBUF_NODISCARD std::string* release_nighttemp();
  void set_allocated_nighttemp(std::string* value);

  private:
  const std::string& _internal_nighttemp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nighttemp(
      const std::string& value);
  std::string* _internal_mutable_nighttemp();

  public:
  // string daywind = 7;
  void clear_daywind() ;
  const std::string& daywind() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_daywind(Arg_&& arg, Args_... args);
  std::string* mutable_daywind();
  PROTOBUF_NODISCARD std::string* release_daywind();
  void set_allocated_daywind(std::string* value);

  private:
  const std::string& _internal_daywind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_daywind(
      const std::string& value);
  std::string* _internal_mutable_daywind();

  public:
  // string nightwind = 8;
  void clear_nightwind() ;
  const std::string& nightwind() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nightwind(Arg_&& arg, Args_... args);
  std::string* mutable_nightwind();
  PROTOBUF_NODISCARD std::string* release_nightwind();
  void set_allocated_nightwind(std::string* value);

  private:
  const std::string& _internal_nightwind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nightwind(
      const std::string& value);
  std::string* _internal_mutable_nightwind();

  public:
  // string daypower = 9;
  void clear_daypower() ;
  const std::string& daypower() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_daypower(Arg_&& arg, Args_... args);
  std::string* mutable_daypower();
  PROTOBUF_NODISCARD std::string* release_daypower();
  void set_allocated_daypower(std::string* value);

  private:
  const std::string& _internal_daypower() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_daypower(
      const std::string& value);
  std::string* _internal_mutable_daypower();

  public:
  // string nightpower = 10;
  void clear_nightpower() ;
  const std::string& nightpower() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nightpower(Arg_&& arg, Args_... args);
  std::string* mutable_nightpower();
  PROTOBUF_NODISCARD std::string* release_nightpower();
  void set_allocated_nightpower(std::string* value);

  private:
  const std::string& _internal_nightpower() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nightpower(
      const std::string& value);
  std::string* _internal_mutable_nightpower();

  public:
  // @@protoc_insertion_point(class_scope:weather.ForecastWeather)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      120, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr date_;
    ::google::protobuf::internal::ArenaStringPtr week_;
    ::google::protobuf::internal::ArenaStringPtr dayweather_;
    ::google::protobuf::internal::ArenaStringPtr nightweather_;
    ::google::protobuf::internal::ArenaStringPtr daytemp_;
    ::google::protobuf::internal::ArenaStringPtr nighttemp_;
    ::google::protobuf::internal::ArenaStringPtr daywind_;
    ::google::protobuf::internal::ArenaStringPtr nightwind_;
    ::google::protobuf::internal::ArenaStringPtr daypower_;
    ::google::protobuf::internal::ArenaStringPtr nightpower_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weather_2eproto;
};// -------------------------------------------------------------------

class LivesWeatherReplay final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:weather.LivesWeatherReplay) */ {
 public:
  inline LivesWeatherReplay() : LivesWeatherReplay(nullptr) {}
  ~LivesWeatherReplay() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LivesWeatherReplay(::google::protobuf::internal::ConstantInitialized);

  inline LivesWeatherReplay(const LivesWeatherReplay& from)
      : LivesWeatherReplay(nullptr, from) {}
  LivesWeatherReplay(LivesWeatherReplay&& from) noexcept
    : LivesWeatherReplay() {
    *this = ::std::move(from);
  }

  inline LivesWeatherReplay& operator=(const LivesWeatherReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline LivesWeatherReplay& operator=(LivesWeatherReplay&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LivesWeatherReplay& default_instance() {
    return *internal_default_instance();
  }
  static inline const LivesWeatherReplay* internal_default_instance() {
    return reinterpret_cast<const LivesWeatherReplay*>(
               &_LivesWeatherReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LivesWeatherReplay& a, LivesWeatherReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(LivesWeatherReplay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LivesWeatherReplay* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LivesWeatherReplay* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LivesWeatherReplay>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LivesWeatherReplay& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LivesWeatherReplay& from) {
    LivesWeatherReplay::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LivesWeatherReplay* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "weather.LivesWeatherReplay";
  }
  protected:
  explicit LivesWeatherReplay(::google::protobuf::Arena* arena);
  LivesWeatherReplay(::google::protobuf::Arena* arena, const LivesWeatherReplay& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLivesWeatherFieldNumber = 1,
  };
  // .weather.LivesWeather livesWeather = 1;
  bool has_livesweather() const;
  void clear_livesweather() ;
  const ::weather::LivesWeather& livesweather() const;
  PROTOBUF_NODISCARD ::weather::LivesWeather* release_livesweather();
  ::weather::LivesWeather* mutable_livesweather();
  void set_allocated_livesweather(::weather::LivesWeather* value);
  void unsafe_arena_set_allocated_livesweather(::weather::LivesWeather* value);
  ::weather::LivesWeather* unsafe_arena_release_livesweather();

  private:
  const ::weather::LivesWeather& _internal_livesweather() const;
  ::weather::LivesWeather* _internal_mutable_livesweather();

  public:
  // @@protoc_insertion_point(class_scope:weather.LivesWeatherReplay)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::weather::LivesWeather* livesweather_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weather_2eproto;
};// -------------------------------------------------------------------

class ForecastWeatherReplay final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:weather.ForecastWeatherReplay) */ {
 public:
  inline ForecastWeatherReplay() : ForecastWeatherReplay(nullptr) {}
  ~ForecastWeatherReplay() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ForecastWeatherReplay(::google::protobuf::internal::ConstantInitialized);

  inline ForecastWeatherReplay(const ForecastWeatherReplay& from)
      : ForecastWeatherReplay(nullptr, from) {}
  ForecastWeatherReplay(ForecastWeatherReplay&& from) noexcept
    : ForecastWeatherReplay() {
    *this = ::std::move(from);
  }

  inline ForecastWeatherReplay& operator=(const ForecastWeatherReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForecastWeatherReplay& operator=(ForecastWeatherReplay&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForecastWeatherReplay& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForecastWeatherReplay* internal_default_instance() {
    return reinterpret_cast<const ForecastWeatherReplay*>(
               &_ForecastWeatherReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ForecastWeatherReplay& a, ForecastWeatherReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(ForecastWeatherReplay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForecastWeatherReplay* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForecastWeatherReplay* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForecastWeatherReplay>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ForecastWeatherReplay& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ForecastWeatherReplay& from) {
    ForecastWeatherReplay::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ForecastWeatherReplay* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "weather.ForecastWeatherReplay";
  }
  protected:
  explicit ForecastWeatherReplay(::google::protobuf::Arena* arena);
  ForecastWeatherReplay(::google::protobuf::Arena* arena, const ForecastWeatherReplay& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForecastWeathersFieldNumber = 2,
    kReporttimeFieldNumber = 1,
  };
  // repeated .weather.ForecastWeather forecastWeathers = 2;
  int forecastweathers_size() const;
  private:
  int _internal_forecastweathers_size() const;

  public:
  void clear_forecastweathers() ;
  ::weather::ForecastWeather* mutable_forecastweathers(int index);
  ::google::protobuf::RepeatedPtrField< ::weather::ForecastWeather >*
      mutable_forecastweathers();
  private:
  const ::google::protobuf::RepeatedPtrField<::weather::ForecastWeather>& _internal_forecastweathers() const;
  ::google::protobuf::RepeatedPtrField<::weather::ForecastWeather>* _internal_mutable_forecastweathers();
  public:
  const ::weather::ForecastWeather& forecastweathers(int index) const;
  ::weather::ForecastWeather* add_forecastweathers();
  const ::google::protobuf::RepeatedPtrField< ::weather::ForecastWeather >&
      forecastweathers() const;
  // string reporttime = 1;
  void clear_reporttime() ;
  const std::string& reporttime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reporttime(Arg_&& arg, Args_... args);
  std::string* mutable_reporttime();
  PROTOBUF_NODISCARD std::string* release_reporttime();
  void set_allocated_reporttime(std::string* value);

  private:
  const std::string& _internal_reporttime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reporttime(
      const std::string& value);
  std::string* _internal_mutable_reporttime();

  public:
  // @@protoc_insertion_point(class_scope:weather.ForecastWeatherReplay)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::weather::ForecastWeather > forecastweathers_;
    ::google::protobuf::internal::ArenaStringPtr reporttime_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weather_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UserInfo

// string username = 1;
inline void UserInfo::clear_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserInfo::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.UserInfo.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_username(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.UserInfo.username)
}
inline std::string* UserInfo::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:weather.UserInfo.username)
  return _s;
}
inline const std::string& UserInfo::_internal_username() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.username_.Get();
}
inline void UserInfo::_internal_set_username(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* UserInfo::release_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.UserInfo.username)
  return _impl_.username_.Release();
}
inline void UserInfo::set_allocated_username(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.UserInfo.username)
}

// string userip = 2;
inline void UserInfo::clear_userip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userip_.ClearToEmpty();
}
inline const std::string& UserInfo::userip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.UserInfo.userip)
  return _internal_userip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_userip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.userip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.UserInfo.userip)
}
inline std::string* UserInfo::mutable_userip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_userip();
  // @@protoc_insertion_point(field_mutable:weather.UserInfo.userip)
  return _s;
}
inline const std::string& UserInfo::_internal_userip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userip_.Get();
}
inline void UserInfo::_internal_set_userip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.userip_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_userip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.userip_.Mutable( GetArena());
}
inline std::string* UserInfo::release_userip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.UserInfo.userip)
  return _impl_.userip_.Release();
}
inline void UserInfo::set_allocated_userip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userip_.IsDefault()) {
          _impl_.userip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.UserInfo.userip)
}

// -------------------------------------------------------------------

// LivesWeather

// string weather = 1;
inline void LivesWeather::clear_weather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weather_.ClearToEmpty();
}
inline const std::string& LivesWeather::weather() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeather.weather)
  return _internal_weather();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LivesWeather::set_weather(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weather_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.LivesWeather.weather)
}
inline std::string* LivesWeather::mutable_weather() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_weather();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeather.weather)
  return _s;
}
inline const std::string& LivesWeather::_internal_weather() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weather_.Get();
}
inline void LivesWeather::_internal_set_weather(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weather_.Set(value, GetArena());
}
inline std::string* LivesWeather::_internal_mutable_weather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.weather_.Mutable( GetArena());
}
inline std::string* LivesWeather::release_weather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeather.weather)
  return _impl_.weather_.Release();
}
inline void LivesWeather::set_allocated_weather(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weather_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.weather_.IsDefault()) {
          _impl_.weather_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeather.weather)
}

// string temperature = 2;
inline void LivesWeather::clear_temperature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.temperature_.ClearToEmpty();
}
inline const std::string& LivesWeather::temperature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeather.temperature)
  return _internal_temperature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LivesWeather::set_temperature(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.temperature_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.LivesWeather.temperature)
}
inline std::string* LivesWeather::mutable_temperature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_temperature();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeather.temperature)
  return _s;
}
inline const std::string& LivesWeather::_internal_temperature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.temperature_.Get();
}
inline void LivesWeather::_internal_set_temperature(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.temperature_.Set(value, GetArena());
}
inline std::string* LivesWeather::_internal_mutable_temperature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.temperature_.Mutable( GetArena());
}
inline std::string* LivesWeather::release_temperature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeather.temperature)
  return _impl_.temperature_.Release();
}
inline void LivesWeather::set_allocated_temperature(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.temperature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.temperature_.IsDefault()) {
          _impl_.temperature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeather.temperature)
}

// string winddirection = 3;
inline void LivesWeather::clear_winddirection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.winddirection_.ClearToEmpty();
}
inline const std::string& LivesWeather::winddirection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeather.winddirection)
  return _internal_winddirection();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LivesWeather::set_winddirection(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.winddirection_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.LivesWeather.winddirection)
}
inline std::string* LivesWeather::mutable_winddirection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_winddirection();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeather.winddirection)
  return _s;
}
inline const std::string& LivesWeather::_internal_winddirection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.winddirection_.Get();
}
inline void LivesWeather::_internal_set_winddirection(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.winddirection_.Set(value, GetArena());
}
inline std::string* LivesWeather::_internal_mutable_winddirection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.winddirection_.Mutable( GetArena());
}
inline std::string* LivesWeather::release_winddirection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeather.winddirection)
  return _impl_.winddirection_.Release();
}
inline void LivesWeather::set_allocated_winddirection(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.winddirection_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.winddirection_.IsDefault()) {
          _impl_.winddirection_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeather.winddirection)
}

// string windpower = 4;
inline void LivesWeather::clear_windpower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.windpower_.ClearToEmpty();
}
inline const std::string& LivesWeather::windpower() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeather.windpower)
  return _internal_windpower();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LivesWeather::set_windpower(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.windpower_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.LivesWeather.windpower)
}
inline std::string* LivesWeather::mutable_windpower() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_windpower();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeather.windpower)
  return _s;
}
inline const std::string& LivesWeather::_internal_windpower() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windpower_.Get();
}
inline void LivesWeather::_internal_set_windpower(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.windpower_.Set(value, GetArena());
}
inline std::string* LivesWeather::_internal_mutable_windpower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.windpower_.Mutable( GetArena());
}
inline std::string* LivesWeather::release_windpower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeather.windpower)
  return _impl_.windpower_.Release();
}
inline void LivesWeather::set_allocated_windpower(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.windpower_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.windpower_.IsDefault()) {
          _impl_.windpower_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeather.windpower)
}

// string humidity = 5;
inline void LivesWeather::clear_humidity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.humidity_.ClearToEmpty();
}
inline const std::string& LivesWeather::humidity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeather.humidity)
  return _internal_humidity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LivesWeather::set_humidity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.humidity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.LivesWeather.humidity)
}
inline std::string* LivesWeather::mutable_humidity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_humidity();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeather.humidity)
  return _s;
}
inline const std::string& LivesWeather::_internal_humidity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.humidity_.Get();
}
inline void LivesWeather::_internal_set_humidity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.humidity_.Set(value, GetArena());
}
inline std::string* LivesWeather::_internal_mutable_humidity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.humidity_.Mutable( GetArena());
}
inline std::string* LivesWeather::release_humidity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeather.humidity)
  return _impl_.humidity_.Release();
}
inline void LivesWeather::set_allocated_humidity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.humidity_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.humidity_.IsDefault()) {
          _impl_.humidity_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeather.humidity)
}

// string reporttime = 6;
inline void LivesWeather::clear_reporttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reporttime_.ClearToEmpty();
}
inline const std::string& LivesWeather::reporttime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeather.reporttime)
  return _internal_reporttime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LivesWeather::set_reporttime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reporttime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.LivesWeather.reporttime)
}
inline std::string* LivesWeather::mutable_reporttime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reporttime();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeather.reporttime)
  return _s;
}
inline const std::string& LivesWeather::_internal_reporttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reporttime_.Get();
}
inline void LivesWeather::_internal_set_reporttime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reporttime_.Set(value, GetArena());
}
inline std::string* LivesWeather::_internal_mutable_reporttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.reporttime_.Mutable( GetArena());
}
inline std::string* LivesWeather::release_reporttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeather.reporttime)
  return _impl_.reporttime_.Release();
}
inline void LivesWeather::set_allocated_reporttime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reporttime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reporttime_.IsDefault()) {
          _impl_.reporttime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeather.reporttime)
}

// string temperatureFloat = 7;
inline void LivesWeather::clear_temperaturefloat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.temperaturefloat_.ClearToEmpty();
}
inline const std::string& LivesWeather::temperaturefloat() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeather.temperatureFloat)
  return _internal_temperaturefloat();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LivesWeather::set_temperaturefloat(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.temperaturefloat_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.LivesWeather.temperatureFloat)
}
inline std::string* LivesWeather::mutable_temperaturefloat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_temperaturefloat();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeather.temperatureFloat)
  return _s;
}
inline const std::string& LivesWeather::_internal_temperaturefloat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.temperaturefloat_.Get();
}
inline void LivesWeather::_internal_set_temperaturefloat(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.temperaturefloat_.Set(value, GetArena());
}
inline std::string* LivesWeather::_internal_mutable_temperaturefloat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.temperaturefloat_.Mutable( GetArena());
}
inline std::string* LivesWeather::release_temperaturefloat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeather.temperatureFloat)
  return _impl_.temperaturefloat_.Release();
}
inline void LivesWeather::set_allocated_temperaturefloat(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.temperaturefloat_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.temperaturefloat_.IsDefault()) {
          _impl_.temperaturefloat_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeather.temperatureFloat)
}

// string humidityFloat = 8;
inline void LivesWeather::clear_humidityfloat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.humidityfloat_.ClearToEmpty();
}
inline const std::string& LivesWeather::humidityfloat() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeather.humidityFloat)
  return _internal_humidityfloat();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LivesWeather::set_humidityfloat(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.humidityfloat_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.LivesWeather.humidityFloat)
}
inline std::string* LivesWeather::mutable_humidityfloat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_humidityfloat();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeather.humidityFloat)
  return _s;
}
inline const std::string& LivesWeather::_internal_humidityfloat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.humidityfloat_.Get();
}
inline void LivesWeather::_internal_set_humidityfloat(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.humidityfloat_.Set(value, GetArena());
}
inline std::string* LivesWeather::_internal_mutable_humidityfloat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.humidityfloat_.Mutable( GetArena());
}
inline std::string* LivesWeather::release_humidityfloat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeather.humidityFloat)
  return _impl_.humidityfloat_.Release();
}
inline void LivesWeather::set_allocated_humidityfloat(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.humidityfloat_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.humidityfloat_.IsDefault()) {
          _impl_.humidityfloat_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeather.humidityFloat)
}

// -------------------------------------------------------------------

// ForecastWeather

// string date = 1;
inline void ForecastWeather::clear_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.date_.ClearToEmpty();
}
inline const std::string& ForecastWeather::date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.date)
  return _internal_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.date)
}
inline std::string* ForecastWeather::mutable_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.date)
  return _s;
}
inline const std::string& ForecastWeather::_internal_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.date_.Get();
}
inline void ForecastWeather::_internal_set_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.date_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.date_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.date)
  return _impl_.date_.Release();
}
inline void ForecastWeather::set_allocated_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.date_.IsDefault()) {
          _impl_.date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.date)
}

// string week = 2;
inline void ForecastWeather::clear_week() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.week_.ClearToEmpty();
}
inline const std::string& ForecastWeather::week() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.week)
  return _internal_week();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_week(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.week_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.week)
}
inline std::string* ForecastWeather::mutable_week() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_week();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.week)
  return _s;
}
inline const std::string& ForecastWeather::_internal_week() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.week_.Get();
}
inline void ForecastWeather::_internal_set_week(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.week_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_week() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.week_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_week() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.week)
  return _impl_.week_.Release();
}
inline void ForecastWeather::set_allocated_week(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.week_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.week_.IsDefault()) {
          _impl_.week_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.week)
}

// string dayweather = 3;
inline void ForecastWeather::clear_dayweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dayweather_.ClearToEmpty();
}
inline const std::string& ForecastWeather::dayweather() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.dayweather)
  return _internal_dayweather();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_dayweather(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dayweather_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.dayweather)
}
inline std::string* ForecastWeather::mutable_dayweather() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dayweather();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.dayweather)
  return _s;
}
inline const std::string& ForecastWeather::_internal_dayweather() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dayweather_.Get();
}
inline void ForecastWeather::_internal_set_dayweather(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dayweather_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_dayweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dayweather_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_dayweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.dayweather)
  return _impl_.dayweather_.Release();
}
inline void ForecastWeather::set_allocated_dayweather(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dayweather_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dayweather_.IsDefault()) {
          _impl_.dayweather_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.dayweather)
}

// string nightweather = 4;
inline void ForecastWeather::clear_nightweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nightweather_.ClearToEmpty();
}
inline const std::string& ForecastWeather::nightweather() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.nightweather)
  return _internal_nightweather();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_nightweather(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nightweather_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.nightweather)
}
inline std::string* ForecastWeather::mutable_nightweather() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nightweather();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.nightweather)
  return _s;
}
inline const std::string& ForecastWeather::_internal_nightweather() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nightweather_.Get();
}
inline void ForecastWeather::_internal_set_nightweather(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nightweather_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_nightweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nightweather_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_nightweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.nightweather)
  return _impl_.nightweather_.Release();
}
inline void ForecastWeather::set_allocated_nightweather(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nightweather_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nightweather_.IsDefault()) {
          _impl_.nightweather_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.nightweather)
}

// string daytemp = 5;
inline void ForecastWeather::clear_daytemp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.daytemp_.ClearToEmpty();
}
inline const std::string& ForecastWeather::daytemp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.daytemp)
  return _internal_daytemp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_daytemp(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.daytemp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.daytemp)
}
inline std::string* ForecastWeather::mutable_daytemp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_daytemp();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.daytemp)
  return _s;
}
inline const std::string& ForecastWeather::_internal_daytemp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.daytemp_.Get();
}
inline void ForecastWeather::_internal_set_daytemp(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.daytemp_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_daytemp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.daytemp_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_daytemp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.daytemp)
  return _impl_.daytemp_.Release();
}
inline void ForecastWeather::set_allocated_daytemp(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.daytemp_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.daytemp_.IsDefault()) {
          _impl_.daytemp_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.daytemp)
}

// string nighttemp = 6;
inline void ForecastWeather::clear_nighttemp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nighttemp_.ClearToEmpty();
}
inline const std::string& ForecastWeather::nighttemp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.nighttemp)
  return _internal_nighttemp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_nighttemp(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nighttemp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.nighttemp)
}
inline std::string* ForecastWeather::mutable_nighttemp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nighttemp();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.nighttemp)
  return _s;
}
inline const std::string& ForecastWeather::_internal_nighttemp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nighttemp_.Get();
}
inline void ForecastWeather::_internal_set_nighttemp(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nighttemp_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_nighttemp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nighttemp_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_nighttemp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.nighttemp)
  return _impl_.nighttemp_.Release();
}
inline void ForecastWeather::set_allocated_nighttemp(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nighttemp_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nighttemp_.IsDefault()) {
          _impl_.nighttemp_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.nighttemp)
}

// string daywind = 7;
inline void ForecastWeather::clear_daywind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.daywind_.ClearToEmpty();
}
inline const std::string& ForecastWeather::daywind() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.daywind)
  return _internal_daywind();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_daywind(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.daywind_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.daywind)
}
inline std::string* ForecastWeather::mutable_daywind() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_daywind();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.daywind)
  return _s;
}
inline const std::string& ForecastWeather::_internal_daywind() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.daywind_.Get();
}
inline void ForecastWeather::_internal_set_daywind(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.daywind_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_daywind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.daywind_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_daywind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.daywind)
  return _impl_.daywind_.Release();
}
inline void ForecastWeather::set_allocated_daywind(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.daywind_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.daywind_.IsDefault()) {
          _impl_.daywind_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.daywind)
}

// string nightwind = 8;
inline void ForecastWeather::clear_nightwind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nightwind_.ClearToEmpty();
}
inline const std::string& ForecastWeather::nightwind() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.nightwind)
  return _internal_nightwind();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_nightwind(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nightwind_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.nightwind)
}
inline std::string* ForecastWeather::mutable_nightwind() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nightwind();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.nightwind)
  return _s;
}
inline const std::string& ForecastWeather::_internal_nightwind() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nightwind_.Get();
}
inline void ForecastWeather::_internal_set_nightwind(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nightwind_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_nightwind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nightwind_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_nightwind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.nightwind)
  return _impl_.nightwind_.Release();
}
inline void ForecastWeather::set_allocated_nightwind(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nightwind_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nightwind_.IsDefault()) {
          _impl_.nightwind_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.nightwind)
}

// string daypower = 9;
inline void ForecastWeather::clear_daypower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.daypower_.ClearToEmpty();
}
inline const std::string& ForecastWeather::daypower() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.daypower)
  return _internal_daypower();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_daypower(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.daypower_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.daypower)
}
inline std::string* ForecastWeather::mutable_daypower() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_daypower();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.daypower)
  return _s;
}
inline const std::string& ForecastWeather::_internal_daypower() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.daypower_.Get();
}
inline void ForecastWeather::_internal_set_daypower(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.daypower_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_daypower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.daypower_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_daypower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.daypower)
  return _impl_.daypower_.Release();
}
inline void ForecastWeather::set_allocated_daypower(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.daypower_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.daypower_.IsDefault()) {
          _impl_.daypower_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.daypower)
}

// string nightpower = 10;
inline void ForecastWeather::clear_nightpower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nightpower_.ClearToEmpty();
}
inline const std::string& ForecastWeather::nightpower() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeather.nightpower)
  return _internal_nightpower();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeather::set_nightpower(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nightpower_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeather.nightpower)
}
inline std::string* ForecastWeather::mutable_nightpower() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nightpower();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeather.nightpower)
  return _s;
}
inline const std::string& ForecastWeather::_internal_nightpower() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nightpower_.Get();
}
inline void ForecastWeather::_internal_set_nightpower(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nightpower_.Set(value, GetArena());
}
inline std::string* ForecastWeather::_internal_mutable_nightpower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nightpower_.Mutable( GetArena());
}
inline std::string* ForecastWeather::release_nightpower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeather.nightpower)
  return _impl_.nightpower_.Release();
}
inline void ForecastWeather::set_allocated_nightpower(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nightpower_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nightpower_.IsDefault()) {
          _impl_.nightpower_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeather.nightpower)
}

// -------------------------------------------------------------------

// LivesWeatherReplay

// .weather.LivesWeather livesWeather = 1;
inline bool LivesWeatherReplay::has_livesweather() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.livesweather_ != nullptr);
  return value;
}
inline void LivesWeatherReplay::clear_livesweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.livesweather_ != nullptr) _impl_.livesweather_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::weather::LivesWeather& LivesWeatherReplay::_internal_livesweather() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::weather::LivesWeather* p = _impl_.livesweather_;
  return p != nullptr ? *p : reinterpret_cast<const ::weather::LivesWeather&>(::weather::_LivesWeather_default_instance_);
}
inline const ::weather::LivesWeather& LivesWeatherReplay::livesweather() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.LivesWeatherReplay.livesWeather)
  return _internal_livesweather();
}
inline void LivesWeatherReplay::unsafe_arena_set_allocated_livesweather(::weather::LivesWeather* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.livesweather_);
  }
  _impl_.livesweather_ = reinterpret_cast<::weather::LivesWeather*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:weather.LivesWeatherReplay.livesWeather)
}
inline ::weather::LivesWeather* LivesWeatherReplay::release_livesweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::weather::LivesWeather* released = _impl_.livesweather_;
  _impl_.livesweather_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::weather::LivesWeather* LivesWeatherReplay::unsafe_arena_release_livesweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.LivesWeatherReplay.livesWeather)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::weather::LivesWeather* temp = _impl_.livesweather_;
  _impl_.livesweather_ = nullptr;
  return temp;
}
inline ::weather::LivesWeather* LivesWeatherReplay::_internal_mutable_livesweather() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.livesweather_ == nullptr) {
    auto* p = CreateMaybeMessage<::weather::LivesWeather>(GetArena());
    _impl_.livesweather_ = reinterpret_cast<::weather::LivesWeather*>(p);
  }
  return _impl_.livesweather_;
}
inline ::weather::LivesWeather* LivesWeatherReplay::mutable_livesweather() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::weather::LivesWeather* _msg = _internal_mutable_livesweather();
  // @@protoc_insertion_point(field_mutable:weather.LivesWeatherReplay.livesWeather)
  return _msg;
}
inline void LivesWeatherReplay::set_allocated_livesweather(::weather::LivesWeather* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::weather::LivesWeather*>(_impl_.livesweather_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::weather::LivesWeather*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.livesweather_ = reinterpret_cast<::weather::LivesWeather*>(value);
  // @@protoc_insertion_point(field_set_allocated:weather.LivesWeatherReplay.livesWeather)
}

// -------------------------------------------------------------------

// ForecastWeatherReplay

// string reporttime = 1;
inline void ForecastWeatherReplay::clear_reporttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reporttime_.ClearToEmpty();
}
inline const std::string& ForecastWeatherReplay::reporttime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeatherReplay.reporttime)
  return _internal_reporttime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastWeatherReplay::set_reporttime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reporttime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:weather.ForecastWeatherReplay.reporttime)
}
inline std::string* ForecastWeatherReplay::mutable_reporttime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reporttime();
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeatherReplay.reporttime)
  return _s;
}
inline const std::string& ForecastWeatherReplay::_internal_reporttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reporttime_.Get();
}
inline void ForecastWeatherReplay::_internal_set_reporttime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reporttime_.Set(value, GetArena());
}
inline std::string* ForecastWeatherReplay::_internal_mutable_reporttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.reporttime_.Mutable( GetArena());
}
inline std::string* ForecastWeatherReplay::release_reporttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:weather.ForecastWeatherReplay.reporttime)
  return _impl_.reporttime_.Release();
}
inline void ForecastWeatherReplay::set_allocated_reporttime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reporttime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reporttime_.IsDefault()) {
          _impl_.reporttime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weather.ForecastWeatherReplay.reporttime)
}

// repeated .weather.ForecastWeather forecastWeathers = 2;
inline int ForecastWeatherReplay::_internal_forecastweathers_size() const {
  return _internal_forecastweathers().size();
}
inline int ForecastWeatherReplay::forecastweathers_size() const {
  return _internal_forecastweathers_size();
}
inline void ForecastWeatherReplay::clear_forecastweathers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.forecastweathers_.Clear();
}
inline ::weather::ForecastWeather* ForecastWeatherReplay::mutable_forecastweathers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:weather.ForecastWeatherReplay.forecastWeathers)
  return _internal_mutable_forecastweathers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::weather::ForecastWeather>* ForecastWeatherReplay::mutable_forecastweathers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:weather.ForecastWeatherReplay.forecastWeathers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_forecastweathers();
}
inline const ::weather::ForecastWeather& ForecastWeatherReplay::forecastweathers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:weather.ForecastWeatherReplay.forecastWeathers)
  return _internal_forecastweathers().Get(index);
}
inline ::weather::ForecastWeather* ForecastWeatherReplay::add_forecastweathers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::weather::ForecastWeather* _add = _internal_mutable_forecastweathers()->Add();
  // @@protoc_insertion_point(field_add:weather.ForecastWeatherReplay.forecastWeathers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::weather::ForecastWeather>& ForecastWeatherReplay::forecastweathers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:weather.ForecastWeatherReplay.forecastWeathers)
  return _internal_forecastweathers();
}
inline const ::google::protobuf::RepeatedPtrField<::weather::ForecastWeather>&
ForecastWeatherReplay::_internal_forecastweathers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.forecastweathers_;
}
inline ::google::protobuf::RepeatedPtrField<::weather::ForecastWeather>*
ForecastWeatherReplay::_internal_mutable_forecastweathers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.forecastweathers_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace weather


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_weather_2eproto_2epb_2eh
